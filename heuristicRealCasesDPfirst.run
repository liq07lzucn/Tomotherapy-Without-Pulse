reset;
model heuristicRealCases.mod;
data tomononlinearRealCases.dat;
option solver gurobi, solution_round 1;
option gurobi_options 'outlev 1';
option gurobi_options 'ams_limit 0';
option gurobi_options 'mip 0';
# The one below cuts like 90% of the time
option gurobi_options 'mipgapabs 2000';
# Reduces the time to a half
option gurobi_options 'feastol 1e-3';
#option gurobi_options 'bariterlim 100';
#option gurobi_options 'barconvtool 100';
problem CMP: y, z, z_plus, z_minus, ObjectiveFunction, doses_to_j, positive_only;
problem DP: mu, betas, z, z_plus, z_minus, ObjectiveFunction, doses_to_j_yparam, positive_only, Mlimits, abs_greater, abs_smaller, alphalimitsNotPerLeaf;#, Nlimits;#, alphalimits;#

# Initialize to default values
let {n in LEAVES, k in PROJECTIONS} betasparam[n,k] := 0;		# All closed
let {k in PROJECTIONS} yparam[k] := U/20; 	  	 		   	     		#Mid-Intensity
let realU := 0;
let {k in PROJECTIONS} yBar[k] := yparam[k];						#Mid-Intensity for the yBar too.
let oldobj := 9999999999;
let newobj := 9999999999;
let DPtimekeeper := 0;
let CMPtimekeeper := 0;
let numberOfIterations := 1;
#################
repeat {
    repeat {
        let oldobj := newobj;
        print "Iteration Number:", numberOfIterations;
        ## DP procedure
        print "Run the Discrete Problem";
        let timeflagold := _total_solve_time;
        solve DP;
        let proctime := _total_solve_time - timeflagold;
        print "DP running time was: ";
        print proctime;
        let DPtimekeeper := DPtimekeeper + proctime;
        print "Done running the DP";

        let {n in LEAVES, k in PROJECTIONS , m in LOOPS} betasparam [n, k] := betas[n,k];

        print "Run the Continuous Master Problem";
        ## CMP procedure
        let timeflagold := _total_solve_time;
        solve CMP;
        let proctime := _total_solve_time - timeflagold;
        print "CMP time was: ";
        print proctime;
        let CMPtimekeeper := CMPtimekeeper + proctime;
        print "Done running the CMP";

        ## Y bar assignment
        #let {k in PROJECTIONS} yBar[k] :=(1- 1/(numberOfIterations+1)) * y[k] +  1/(numberOfIterations+1) * yBar[k];
        let {k in PROJECTIONS} yBar[k] :=(1- 1/2) * y[k] +  1/2 * yBar[k];
        let {k in PROJECTIONS} yparam[k] := yBar[k];

        let newobj := ObjectiveFunction;

        # Change gurobi conditions
        if abs(newobj - oldobj)/oldobj < 0.1 then
           option gurobi_options 'mipgap 0.001';
        else
           option gurobi_options 'mipgap 0.1';

        # Exit condition
        if abs(newobj - oldobj)/oldobj < 0.001 then break;
        else let numberOfIterations := numberOfIterations + 1;
    }
    let {k in PROJECTIONS} yparam[k] := U;
    if (0 == realU) then
        let realU := 1;
    else
        break;
}
solve;
display y;
display z;
#display z_plus;
#display z_minus;
#display thethreshold;
#display positive_only;
#display DPtimekeeper;
#display CMPtimekeeper;
#display numberOfIterations;
